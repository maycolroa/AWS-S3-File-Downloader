import pandas as pd
import time
import os
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
import logging

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AWSDownloader:
    def __init__(self, csv_file="Informacion archivos cargados Ruta Costera.csv", download_folder="downloads_test"):
        self.csv_file = csv_file
        self.download_folder = download_folder
        self.driver = None
        self.wait = None
        
        # Crear carpeta de descarga
        Path(download_folder).mkdir(exist_ok=True)
        
    def setup_driver(self):
        """Configurar Chrome driver con opciones optimizadas"""
        logger.info("üîß Configurando Chrome driver...")
        
        chrome_options = Options()
        
        # Configurar carpeta de descarga
        download_path = os.path.abspath(self.download_folder)
        prefs = {
            "download.default_directory": download_path,
            "download.prompt_for_download": False,
            "download.directory_upgrade": True,
            "safebrowsing.enabled": True,
            "profile.default_content_settings.popups": 0,
            "profile.default_content_setting_values.automatic_downloads": 1
        }
        chrome_options.add_experimental_option("prefs", prefs)
        
        # Opciones adicionales para mejor rendimiento
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--disable-blink-features=AutomationControlled")
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        
        # Instalar y usar ChromeDriver autom√°ticamente
        service = Service(ChromeDriverManager().install())
        self.driver = webdriver.Chrome(service=service, options=chrome_options)
        
        # Configurar script para evitar detecci√≥n
        self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        
        self.wait = WebDriverWait(self.driver, 20)
        logger.info("‚úÖ Chrome driver configurado correctamente")
        
    def load_files_from_csv(self):
        """Cargar lista de archivos desde CSV"""
        logger.info(f"üìÅ Cargando archivos desde {self.csv_file}")
        
        try:
            if self.csv_file.endswith('.csv'):
                # Intentar m√∫ltiples estrategias de lectura
                try:
                    # Estrategia 1: Detectar separador autom√°ticamente
                    # Leer primera l√≠nea para detectar separador
                    with open(self.csv_file, 'r', encoding='utf-8') as f:
                        first_line = f.readline()
                    
                    # Detectar separador
                    if ';' in first_line and first_line.count(';') > first_line.count(','):
                        separator = ';'
                        logger.info("üîç Detectado separador: punto y coma (;)")
                    else:
                        separator = ','
                        logger.info("üîç Detectado separador: coma (,)")
                    
                    df = pd.read_csv(self.csv_file, sep=separator)
                    
                except Exception as e1:
                    logger.warning(f"‚ö†Ô∏è Estrategia 1 fall√≥: {e1}")
                    try:
                        # Estrategia 2: Forzar punto y coma
                        df = pd.read_csv(self.csv_file, sep=';')
                        logger.info("üîß Usando separador forzado: punto y coma (;)")
                    except Exception as e2:
                        logger.warning(f"‚ö†Ô∏è Estrategia 2 fall√≥: {e2}")
                        try:
                            # Estrategia 3: Forzar coma
                            df = pd.read_csv(self.csv_file, sep=',')
                            logger.info("üîß Usando separador forzado: coma (,)")
                        except Exception as e3:
                            logger.warning(f"‚ö†Ô∏è Estrategia 3 fall√≥: {e3}")
                            # Estrategia 4: Con engine python (m√°s lento pero m√°s robusto)
                            df = pd.read_csv(
                                self.csv_file,
                                engine='python',
                                sep=None,  # Auto-detectar separador
                                on_bad_lines='skip'
                            )
                            logger.info("üîß Usando auto-detecci√≥n de separador")
            else:
                df = pd.read_excel(self.csv_file)
            
            # Verificar columnas
            logger.info(f"üìã Columnas encontradas: {list(df.columns)}")
            
            if 'file' not in df.columns:
                logger.error(f"‚ùå No se encontr√≥ la columna 'file'. Columnas disponibles: {list(df.columns)}")
                return []
                
            files = df['file'].dropna().unique().tolist()
            logger.info(f"üìä Se encontraron {len(files)} archivos para descargar")
            
            # Mostrar algunas muestras para verificar
            if files:
                logger.info(f"üìÑ Ejemplos de archivos encontrados:")
                for i, file in enumerate(files[:3]):
                    logger.info(f"  {i+1}. {file}")
                if len(files) > 3:
                    logger.info(f"  ... y {len(files) - 3} m√°s")
            
            return files
            
        except Exception as e:
            logger.error(f"‚ùå Error leyendo archivo CSV: {e}")
            return self._read_csv_manual()
    
    def _read_csv_manual(self):
        """Leer CSV manualmente l√≠nea por l√≠nea como backup"""
        logger.info("üîß Intentando lectura manual del CSV...")
        
        files = []
        try:
            with open(self.csv_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                
            # Buscar la l√≠nea de headers y detectar separador
            header_line = None
            file_column_index = None
            separator = ','
            
            for i, line in enumerate(lines[:10]):  # Buscar en las primeras 10 l√≠neas
                if 'file' in line.lower():
                    header_line = i
                    
                    # Detectar separador
                    if ';' in line and line.count(';') > line.count(','):
                        separator = ';'
                        logger.info("üîç Separador detectado en lectura manual: punto y coma (;)")
                    else:
                        separator = ','
                        logger.info("üîç Separador detectado en lectura manual: coma (,)")
                    
                    headers = [h.strip().strip('"') for h in line.strip().split(separator)]
                    if 'file' in headers:
                        file_column_index = headers.index('file')
                        break
            
            if file_column_index is None:
                logger.error("‚ùå No se encontr√≥ la columna 'file' en el archivo")
                return []
            
            logger.info(f"üìç Columna 'file' encontrada en posici√≥n {file_column_index}")
            
            # Leer los datos
            for i, line in enumerate(lines[header_line + 1:], header_line + 2):
                try:
                    # Dividir la l√≠nea por el separador detectado
                    if separator == ';':
                        parts = [part.strip().strip('"') for part in line.strip().split(';')]
                    else:
                        # Para comas, manejar comillas
                        parts = []
                        current_part = ""
                        inside_quotes = False
                        
                        for char in line.strip():
                            if char == '"':
                                inside_quotes = not inside_quotes
                            elif char == ',' and not inside_quotes:
                                parts.append(current_part.strip().strip('"'))
                                current_part = ""
                            else:
                                current_part += char
                        
                        if current_part:
                            parts.append(current_part.strip().strip('"'))
                    
                    # Extraer el archivo si hay suficientes columnas
                    if len(parts) > file_column_index and parts[file_column_index].strip():
                        file_name = parts[file_column_index].strip()
                        if file_name and file_name != 'file':
                            files.append(file_name)
                
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Error en l√≠nea {i}: {e}")
                    continue
            
            # Eliminar duplicados
            files = list(set(files))
            logger.info(f"üìä Lectura manual completada: {len(files)} archivos √∫nicos encontrados")
            
            # Mostrar ejemplos
            if files:
                logger.info(f"üìÑ Ejemplos de archivos encontrados:")
                for i, file in enumerate(files[:3]):
                    logger.info(f"  {i+1}. {file}")
            
            return files
            
        except Exception as e:
            logger.error(f"‚ùå Error en lectura manual: {e}")
            return []
    
    def wait_for_user_navigation(self):
        """Esperar a que el usuario navegue manualmente a S3"""
        print("\n" + "="*60)
        print("üß™ MODO PRUEBA - INSTRUCCIONES:")
        print("1. El navegador se abrir√° autom√°ticamente")
        print("2. Navega manualmente a tu bucket de AWS S3")
        print("3. Ve a la carpeta 'legalAspects/files/' (o donde est√©n tus archivos)")
        print("4. Cuando est√©s listo, presiona Enter en esta consola")
        print("5. üõ°Ô∏è SOLO SE DESCARGAR√ÅN 5 ARCHIVOS COMO PRUEBA")
        print("="*60 + "\n")
        
        input("‚è≥ Presiona Enter cuando est√©s en la p√°gina correcta de S3...")
        logger.info("üöÄ Iniciando proceso de descarga autom√°tica - MODO PRUEBA")
    
    def search_and_download_file(self, filename, file_number, total_files):
        """Buscar y descargar un archivo espec√≠fico"""
        try:
            print(f"\nüîç PRUEBA ({file_number}/{total_files}): {filename}")
            print("   ‚è≥ Presiona Ctrl+C si quieres parar la prueba...")
            
            # Buscar el campo de b√∫squeda con m√∫ltiples selectores
            search_selectors = [
                "//input[contains(@placeholder, 'Buscar objetos')]",
                "//input[contains(@placeholder, 'Search objects')]",
                "//input[contains(@placeholder, 'buscar')]",
                "//input[@type='text' and contains(@class, 'search')]"
            ]
            
            search_box = None
            for selector in search_selectors:
                try:
                    search_box = self.wait.until(EC.presence_of_element_located((By.XPATH, selector)))
                    break
                except:
                    continue
            
            if not search_box:
                print(f"   ‚ùå No se encontr√≥ el campo de b√∫squeda")
                return False
            
            print(f"   üîç Buscando archivo...")
            # Limpiar b√∫squeda anterior y buscar archivo
            search_box.clear()
            time.sleep(0.5)
            search_box.send_keys(filename)
            search_box.send_keys(Keys.ENTER)
            
            # Esperar resultados
            time.sleep(3)
            
            # Buscar el archivo en los resultados
            file_selectors = [
                f"//a[contains(text(), '{filename}')]",
                f"//span[contains(text(), '{filename}')]/ancestor::a",
                f"//td[contains(text(), '{filename}')]/ancestor::tr//a"
            ]
            
            file_link = None
            for selector in file_selectors:
                try:
                    file_link = self.wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                    break
                except:
                    continue
            
            if not file_link:
                print(f"   ‚ö†Ô∏è No se encontr√≥ el archivo en los resultados")
                return False
            
            print(f"   üìÅ Archivo encontrado, abriendo...")
            # Click en el archivo
            file_link.click()
            time.sleep(3)
            
            # Buscar bot√≥n de descarga
            download_selectors = [
                "//button[contains(text(), 'Descargar')]",
                "//button[contains(text(), 'Download')]",
                "//a[contains(text(), 'Descargar')]",
                "//a[contains(text(), 'Download')]",
                "//span[contains(text(), 'Descargar')]/ancestor::button",
                "//span[contains(text(), 'Download')]/ancestor::button"
            ]
            
            download_button = None
            for selector in download_selectors:
                try:
                    download_button = self.wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                    break
                except:
                    continue
            
            if download_button:
                print(f"   ‚¨áÔ∏è Iniciando descarga...")
                download_button.click()
                print(f"   ‚úÖ √âXITO: Descarga iniciada")
                time.sleep(2)
                
                # Volver a la lista
                self.driver.back()
                time.sleep(2)
                return True
            else:
                print(f"   ‚ùå No se encontr√≥ bot√≥n de descarga")
                self.driver.back()
                time.sleep(2)
                return False
                
        except Exception as e:
            print(f"   ‚ùå Error procesando archivo: {e}")
            try:
                self.driver.back()
                time.sleep(2)
            except:
                pass
            return False
    
    def download_test_files(self, max_files=5):
        """Proceso de prueba con pocos archivos"""
        files_to_download = self.load_files_from_csv()
        if not files_to_download:
            return
        
        # LIMITACI√ìN PARA PRUEBA
        files_to_download = files_to_download[:max_files]
        print(f"\nüß™ MODO PRUEBA: Solo procesando {len(files_to_download)} archivos")
        print(f"üìÅ Los archivos se guardar√°n en: {os.path.abspath(self.download_folder)}")
        
        self.setup_driver()
        
        try:
            # Abrir navegador y esperar navegaci√≥n manual
            self.driver.get("https://console.aws.amazon.com")
            self.wait_for_user_navigation()
            
            successful_downloads = 0
            failed_downloads = []
            
            # Procesar cada archivo
            for i, filename in enumerate(files_to_download, 1):
                success = self.search_and_download_file(filename, i, len(files_to_download))
                
                if success:
                    successful_downloads += 1
                else:
                    failed_downloads.append(filename)
                
                # Pausa m√°s larga en modo prueba
                print("   ‚è±Ô∏è Esperando 3 segundos antes del siguiente...")
                time.sleep(3)
            
            # Resumen de prueba
            print("\n" + "="*60)
            print("üß™ RESUMEN DE PRUEBA:")
            print(f"Archivos probados: {len(files_to_download)}")
            print(f"Descargas exitosas: {successful_downloads}")
            print(f"Fallos: {len(failed_downloads)}")
            if len(files_to_download) > 0:
                print(f"Tasa de √©xito: {(successful_downloads/len(files_to_download)*100):.1f}%")
            
            if failed_downloads:
                print(f"\n‚ùå Archivos que fallaron:")
                for file in failed_downloads:
                    print(f"  - {file}")
            
            if successful_downloads > 0:
                print(f"\n‚úÖ ¬°PRUEBA EXITOSA! El sistema funciona.")
                print(f"üìÅ Revisa tu carpeta '{self.download_folder}/' para confirmar")
                print(f"üöÄ Si todo est√° bien, puedes ejecutar la versi√≥n completa")
            else:
                print(f"\n‚ö†Ô∏è Ninguna descarga fue exitosa. Revisa la configuraci√≥n.")
            
            print("="*60)
            
        except KeyboardInterrupt:
            print(f"\n\n‚èπÔ∏è Prueba interrumpida por el usuario")
            print(f"üìä Descargas completadas hasta ahora: {successful_downloads}")
            
        finally:
            print("\n‚è≥ Esperando 10 segundos antes de cerrar...")
            time.sleep(10)
            if self.driver:
                self.driver.quit()

def main():
    """Funci√≥n principal MODO PRUEBA"""
    print("üß™ AWS S3 File Downloader - MODO PRUEBA")
    print("="*50)
    print("üõ°Ô∏è Esta versi√≥n solo descargar√° 5 archivos como prueba")
    print("üìÅ Los archivos se guardar√°n en 'downloads_test/'")
    print("="*50)
    
    csv_file = "Informacion archivos cargados Ruta Costera.csv"
    download_folder = "downloads_test"  # Carpeta diferente para pruebas
    
    if not os.path.exists(csv_file):
        print(f"‚ùå No se encontr√≥ el archivo: {csv_file}")
        print("üìÅ Archivos disponibles en el directorio:")
        for file in os.listdir("."):
            if file.endswith(('.csv', '.xlsx', '.xls')):
                print(f"  - {file}")
        return
    
    # Crear downloader para prueba
    downloader = AWSDownloader(csv_file, download_folder)
    downloader.download_test_files(max_files=5)  # Solo 5 archivos

if __name__ == "__main__":
    main()
    